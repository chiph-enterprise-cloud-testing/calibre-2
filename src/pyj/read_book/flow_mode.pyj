# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>
from __python__ import bound_methods, hash_literals

from select import word_at_point

from dom import set_css
from read_book.globals import current_spine_item, get_boss
from read_book.settings import opts
from read_book.viewport import scroll_viewport
from utils import document_height, viewport_to_document


def line_height():
    try:
        # will fail if line-height = "normal"
        lh = parseFloat(line_height.doc_style.lineHeight)
    except:
        lh = 1.2 * parseFloat(line_height.doc_style.fontSize)

    return lh

def flow_to_scroll_fraction(frac, on_initial_load):
    scroll_viewport.scroll_to(0, document_height() * frac)


small_scroll_events = v'[]'


def clear_small_scrolls():
    nonlocal small_scroll_events
    small_scroll_events = v'[]'


def dispatch_small_scrolls():
    if small_scroll_events.length:
        now = window.performance.now()
        if now - small_scroll_events[-1].time <= 2000:
            window.setTimeout(dispatch_small_scrolls, 100)
            return
        amt = 0
        for x in small_scroll_events:
            amt += x.amt
        clear_small_scrolls()
        get_boss().report_human_scroll(amt / document_height())


def add_small_scroll(amt):
    small_scroll_events.push({'amt': amt, 'time': window.performance.now()})
    window.setTimeout(dispatch_small_scrolls, 100)


def report_human_scroll(amt):
    if amt > 0:
        h = scroll_viewport.height()
        is_large_scroll = (amt / h) >= 0.5
        if is_large_scroll:
            clear_small_scrolls()
            get_boss().report_human_scroll(amt / document_height())
        else:
            add_small_scroll(amt)
    else:
        clear_small_scrolls()


last_change_spine_item_request = {}


def _check_for_scroll_end(func, obj, args, report):
    before = window.pageYOffset
    func.apply(obj, args)

    now = performance.now()
    scroll_animator.sync(now)

    if window.pageYOffset is before:
        csi = current_spine_item()
        if last_change_spine_item_request.name is csi.name and now - last_change_spine_item_request.at < 2000:
            return False
        last_change_spine_item_request.name = csi.name
        last_change_spine_item_request.at = now
        get_boss().send_message('next_spine_item', previous=args[0] < 0)
        return False
    if report:
        report_human_scroll(window.pageYOffset - before)
    return True


def check_for_scroll_end(func):
    return def ():
        return _check_for_scroll_end(func, this, arguments, False)


def check_for_scroll_end_and_report(func):
    return def ():
        return _check_for_scroll_end(func, this, arguments, True)


@check_for_scroll_end_and_report
def scroll_by(y):
    window.scrollBy(0, y)


def flow_onwheel(evt):
    dx = dy = 0
    WheelEvent = window.WheelEvent
    if evt.deltaY:
        if evt.deltaMode is WheelEvent.DOM_DELTA_PIXEL:
            dy = evt.deltaY
        elif evt.deltaMode is WheelEvent.DOM_DELTA_LINE:
            dy = line_height() * evt.deltaY
        if evt.deltaMode is WheelEvent.DOM_DELTA_PAGE:
            dy = (scroll_viewport.height() - 30) * evt.deltaY
    if evt.deltaX:
        if evt.deltaMode is WheelEvent.DOM_DELTA_PIXEL:
            dx = evt.deltaX
        elif evt.deltaMode is WheelEvent.DOM_DELTA_LINE:
            dx = 15 * evt.deltaX
        else:
            dx = (scroll_viewport.width() - 30) * evt.deltaX
    if dx:
        window.scrollBy(dx, 0)
    elif Math.abs(dy) >= 1:
        scroll_by(dy)

@check_for_scroll_end
def goto_boundary(dir):
    scroll_viewport.scroll_to(window.pageXOffset, 0 if dir is DIRECTION.Up else document_height())
    get_boss().report_human_scroll()


@check_for_scroll_end_and_report
def scroll_by_page(direction):
    h = scroll_viewport.height() - 10
    window.scrollBy(0, h * direction)


def handle_shortcut(sc_name, evt):
    if sc_name is 'down':
        scroll_animator.start(DIRECTION.Down, False)
        return True
    if sc_name is 'up':
        scroll_animator.start(DIRECTION.Up, False)
        return True
    if sc_name is 'start_of_file':
        goto_boundary(DIRECTION.Up)
        return True
    if sc_name is 'end_of_file':
        goto_boundary(DIRECTION.Down)
        return True
    if sc_name is 'left':
        window.scrollBy(-15, 0)
        return True
    if sc_name is 'right':
        window.scrollBy(15, 0)
        return True
    if sc_name is 'start_of_book':
        get_boss().send_message('goto_doc_boundary', start=True)
        return True
    if sc_name is 'end_of_book':
        get_boss().send_message('goto_doc_boundary', start=False)
        return True
    if sc_name is 'pageup':
        scroll_by_page(-1)
        return True
    if sc_name is 'pagedown':
        scroll_by_page(1)
        return True
    if sc_name is 'toggle_autoscroll':
        if scroll_animator.auto and scroll_animator.is_running():
            cancel_scroll()
        else:
            scroll_animator.start(DIRECTION.Down, True)
        return True

    if sc_name.startsWith('scrollspeed_'):
        scroll_animator.sync()

    return False


def layout(is_single_page):
    cancel_scroll()
    set_css(document.body, margin='0', border_width='0', padding='0')
    line_height.doc_style = window.getComputedStyle(document.body)

def cancel_scroll():
    scroll_animator.stop()

def is_scroll_end(pos):
    return !(0 <= pos <= document_height() - window.innerHeight)

DIRECTION = {'Up': -1, 'Down': 1}
class ScrollAnimator:
    DURATION = 100 # milliseconds

    def __init__(self):
        self.animation_id = None
        self.auto = False

    def is_running(self):
        return self.animation_id != None

    def start(self, direction, auto):
        now = performance.now()
        self.end_time = now + self.DURATION

        if !self.is_running() or direction != self.direction or auto != self.auto:
            self.paused = self.direction if self.auto and not auto else False
            self.stop()
            self.auto = auto
            self.direction = direction
            self.start_time = now
            self.start_offset = window.pageYOffset
            self.animation_id = window.requestAnimationFrame(self.auto_scroll if auto else self.smooth_scroll)

    def smooth_scroll(self, ts):
        duration = (self.end_time - self.start_time)
        progress = max(0, min(1, (ts - self.start_time) / duration)) # max/min to account for jitter
        scroll_target = self.start_offset
        scroll_target += Math.trunc(self.direction * progress * duration * line_height() * opts.lines_per_sec_smooth) / 1000

        window.scrollTo(0, scroll_target)

        if progress < 1:
            self.animation_id = window.requestAnimationFrame(self.smooth_scroll)
        else:
            amt = window.pageYOffset - self.start_offset
            if abs(amt) < 3 and duration is self.DURATION and is_scroll_end(scroll_target):
                get_boss().send_message('next_spine_item', previous=self.direction is DIRECTION.Up)
            elif self.paused:
                self.start(self.paused, True)
            else:
                self.animation_id = None
                report_human_scroll(amt)

    def auto_scroll(self, ts):
        elapsed = max(0, ts - self.start_time) # max to account for jitter
        scroll_target = self.start_offset
        scroll_target += Math.trunc(self.direction * elapsed * line_height() * opts.lines_per_sec_auto) / 1000

        window.scrollTo(0, scroll_target)
        scroll_finished = is_scroll_end(scroll_target)

        # report every second
        if elapsed >= 1000:
            self.sync(ts)

        if scroll_finished:
            self.stop()
        else:
            self.animation_id = window.requestAnimationFrame(self.auto_scroll)

    def sync(self, ts):
        if self.auto:
            report_human_scroll(window.pageYOffset - self.start_offset)
            self.start_time = ts or performance.now()
            self.start_offset = window.pageYOffset

    def stop(self):
        self.auto = False
        if self.animation_id is not None:
            window.cancelAnimationFrame(self.animation_id)
            self.animation_id = None
            amt = window.pageYOffset - self.start_offset
            if amt > 0:
                report_human_scroll(amt)

scroll_animator = ScrollAnimator()


class FlickAnimator:

    SPEED_FACTOR = 0.04
    DECEL_TIME_CONSTANT = 325  # milliseconds
    VELOCITY_HISTORY = 300  # milliseconds
    MIMUMUM_VELOCITY = 100  # pixels/sec

    def __init__(self):
        self.animation_id = None

    def start(self, gesture):
        self.vertical = gesture.axis is 'vertical'
        now = window.performance.now()
        points = times = None
        for i, t in enumerate(gesture.times):
            if now - t < self.VELOCITY_HISTORY:
                points, times = gesture.points[i:], gesture.times[i:]
                break
        if times and times.length > 1:
            elapsed = (times[-1] - times[0]) / 1000
            if elapsed > 0 and points.length > 1:
                delta = points[0] - points[-1]
                velocity = delta / elapsed
                if abs(velocity) > self.MIMUMUM_VELOCITY:
                    self.amplitude = self.SPEED_FACTOR * velocity
                    self.start_time = now
                    self.animation_id = window.requestAnimationFrame(self.auto_scroll)

    def auto_scroll(self, ts):
        if self.animation_id is None:
            return
        elapsed = window.performance.now() - self.start_time
        delta = self.amplitude * Math.exp(-elapsed / self.DECEL_TIME_CONSTANT)
        if abs(delta) >= 1:
            delta = Math.round(delta)
            if self.vertical:
                window.scrollBy(0, delta)
            else:
                window.scrollBy(delta, 0)
            self.animation_id = window.requestAnimationFrame(self.auto_scroll)

    def stop(self):
        if self.animation_id is not None:
            window.cancelAnimationFrame(self.animation_id)
            self.animation_id = None

flick_animator = FlickAnimator()

def handle_gesture(gesture):
    flick_animator.stop()
    if gesture.type is 'swipe':
        if gesture.points.length > 1 and not gesture.is_held:
            delta = gesture.points[-2] - gesture.points[-1]
            if Math.abs(delta) >= 1:
                if gesture.axis is 'vertical':
                    scroll_by(delta)
                else:
                    window.scrollBy(delta, 0)
        if not gesture.active and not gesture.is_held:
            flick_animator.start(gesture)
    elif gesture.type is 'prev-page':
        scroll_by_page(-1)
    elif gesture.type is 'next-page':
        scroll_by_page(1)
    elif gesture.type is 'long-tap':
        r = word_at_point(gesture.viewport_x, gesture.viewport_y)
        if r:
            s = document.getSelection()
            s.removeAllRanges()
            s.addRange(r)
            get_boss().send_message('lookup_word', word=str(r))


anchor_funcs = {
    'pos_for_elem': def pos_for_elem(elem):
        if not elem:
            return 0, 0
        br = elem.getBoundingClientRect()
        x, y = viewport_to_document(br.left, br.top, elem.ownerDocument)
        return y, x
    ,
    'visibility': def visibility(pos):
        y, x = pos
        if y < window.pageYOffset:
            return -1
        if y < window.pageYOffset + scroll_viewport.height():
            if x < window.pageXOffset:
                return -1
            if x < window.pageXOffset + scroll_viewport.width():
                return 0
        return 1
    ,
    'cmp': def cmp(a, b):
        return (a[0] - b[0]) or (a[1] - b[1])
    ,
}
