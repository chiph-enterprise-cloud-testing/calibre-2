# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2020, Kovid Goyal <kovid at kovidgoyal.net>
from __python__ import bound_methods, hash_literals

from dom import ensure_id, svgicon
from read_book.shortcuts import shortcut_for_key_event

WAITING_FOR_CLICK = 1
WAITING_FOR_DRAG = 2
DRAGGING_LEFT = 3
DRAGGING_RIGHT = 4


def selection_handle(invert):
    ans = svgicon('selection-handle')
    s = ans.style
    if invert:
        s.transform = 'scaleX(-1)'
    s.position = 'absolute'
    s.boxSizing = 'border-box'
    s.touchAction = 'none'
    return ans


def map_from_iframe_coords(point):
    l = document.getElementById('book-left-margin')
    point.x += l.offsetWidth
    t = document.getElementById('book-top-margin')
    point.y += t.offsetHeight
    return point


def map_to_iframe_coords(point):
    l = document.getElementById('book-left-margin')
    point.x -= l.offsetWidth
    t = document.getElementById('book-top-margin')
    point.y -= t.offsetHeight
    return point


class CreateAnnotation:

    container_id = 'create-annotation-overlay'

    def __init__(self, view):
        self.view = view
        self.state = WAITING_FOR_CLICK
        self.left_line_height = self.right_line_height = 8
        self.in_flow_mode = False
        container = self.container
        self.position_in_handle = {'x': 0, 'y': 0}

        lh = selection_handle(True)
        self.left_handle_id = ensure_id(lh, 'handle')
        lh.addEventListener('mousedown', self.mousedown_on_handle, {'passive': False})
        container.appendChild(lh)
        rh = selection_handle(False)
        self.right_handle_id = ensure_id(rh, 'handle')
        rh.addEventListener('mousedown', self.mousedown_on_handle, {'passive': False})
        container.appendChild(rh)

        container.addEventListener('click', self.container_clicked, {'passive': False})
        container.addEventListener('mouseup', self.mouseup_on_container, {'passive': False})
        container.addEventListener('mousemove', self.mousemove_on_container, {'passive': False})
        container.addEventListener('keydown', self.on_keydown, {'passive': False})

    def on_keydown(self, ev):
        ev.stopPropagation(), ev.preventDefault()
        sc_name = shortcut_for_key_event(ev, self.view.keyboard_shortcut_map)
        if sc_name is 'show_chrome':
            self.hide()
        elif sc_name in ('up', 'down', 'pageup', 'pagedown'):
            self.send_message('scroll', backwards=bool('up' in sc_name))
        elif sc_name in ('left', 'right'):
            if self.in_flow_mode:
                self.send_message('perp-scroll', backwards=bool(sc_name is 'left'))
            else:
                self.send_message('scroll', backwards=bool(sc_name is 'left'))

    def container_clicked(self, ev):
        ev.stopPropagation(), ev.preventDefault()
        if self.state is WAITING_FOR_CLICK:
            pt = map_to_iframe_coords({'x': ev.clientX, 'y': ev.clientY})
            self.send_message('position-handles-at-point', x=pt.x, y=pt.y)

    def mousedown_on_handle(self, ev):
        ev.stopPropagation(), ev.preventDefault()
        if self.state is WAITING_FOR_CLICK:
            return
        q = ev.currentTarget.id
        if q is self.left_handle_id:
            self.state = DRAGGING_LEFT
            handle = self.left_handle
        elif q is self.right_handle_id:
            self.state = DRAGGING_RIGHT
            handle = self.right_handle
        r = handle.getBoundingClientRect()
        self.position_in_handle.x = Math.round(ev.clientX - r.left)
        self.position_in_handle.y = Math.round(ev.clientY - r.top)

    def mouseup_on_container(self, ev):
        if self.state in (DRAGGING_RIGHT, DRAGGING_LEFT):
            self.state = WAITING_FOR_DRAG
            ev.preventDefault(), ev.stopPropagation()

    def mousemove_on_container(self, ev):
        if self.state not in (DRAGGING_RIGHT, DRAGGING_LEFT):
            return
        ev.stopPropagation(), ev.preventDefault()
        handle = self.left_handle if self.state is DRAGGING_LEFT else self.right_handle
        s = handle.style
        s.left = (ev.clientX - self.position_in_handle.x) + 'px'
        s.top = (ev.clientY - self.position_in_handle.y) + 'px'
        pos = self.current_handle_position
        pos.start = map_to_iframe_coords(pos.start)
        pos.end = map_to_iframe_coords(pos.end)
        self.send_message('set-selection', extents=pos)

    @property
    def container(self):
        return document.getElementById(self.container_id)

    @property
    def left_handle(self):
        return document.getElementById(self.left_handle_id)

    @property
    def right_handle(self):
        return document.getElementById(self.right_handle_id)

    @property
    def is_visible(self):
        return self.container.style.display is not 'none'

    @property
    def current_handle_position(self):
        lh, rh = self.left_handle, self.right_handle
        lbr, rbr = self.left_handle.getBoundingClientRect(), self.right_handle.getBoundingClientRect()
        return {
            'start': {
                'onscreen': lh.style.display is not 'none',
                'x': Math.round(lbr.right), 'y': Math.round(lbr.bottom - self.left_line_height // 2)
            },
            'end': {
                'onscreen': rh.style.display is not 'none',
                'x': Math.round(rbr.left), 'y': Math.round(rbr.bottom - self.right_line_height // 2)
            }
        }

    def show(self):
        c = self.container
        c.style.display = 'block'
        c.focus()

    def hide(self):
        if self.is_visible:
            self.container.style.display = 'none'
            self.view.focus_iframe()

    def send_message(self, type, **kw):
        self.view.iframe_wrapper.send_message('annotations', type=type, **kw)

    def handle_message(self, msg):
        if msg.type is 'create-annotation':
            if not self.is_visible:
                self.view.hide_overlays()
            self.state = WAITING_FOR_CLICK
            self.show()
            self.hide_handles()
            if msg.extents.start.x is not None:
                self.place_handles(msg.extents)
            self.in_flow_mode = msg.in_flow_mode
        elif msg.type is 'position-handles':
            if self.state is WAITING_FOR_CLICK:
                self.place_handles(msg.extents)
        elif msg.type is 'update-handles':
            self.place_handles(msg.extents)
        else:
            print('Ignoring annotations message with unknown type:', msg.type)

    def hide_handles(self):
        self.left_handle.style.display = 'none'
        self.right_handle.style.display = 'none'

    def place_handles(self, extents):
        lh, rh = self.left_handle, self.right_handle

        def do_it(handle, data):
            map_from_iframe_coords(data)
            s = handle.style
            s.display = 'block' if data.onscreen else 'none'
            height = data.height * 3
            width = data.height * 2
            s.width = f'{width}px'
            s.height = f'{height}px'
            bottom = data.y + data.height
            top = bottom - height
            s.top = f'{top}px'
            return s, width

        style, width = do_it(lh, extents.start)
        style.left = (extents.start.x - width) + 'px'
        style, width = do_it(rh, extents.end)
        style.left = extents.end.x + 'px'
        self.state = WAITING_FOR_DRAG
        self.left_line_height = extents.start.height
        self.right_line_height = extents.end.height
