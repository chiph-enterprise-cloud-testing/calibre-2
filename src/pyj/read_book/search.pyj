# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2017, Kovid Goyal <kovid at kovidgoyal.net>
from __python__ import bound_methods, hash_literals

from elementmaker import E

from book_list.theme import get_color
from complete import create_search_bar
from dom import add_extra_css, build_rule, svgicon
from gettext import gettext as _
from modals import error_dialog
from read_book.globals import ui_operations
from read_book.resources import text_from_serialized_html
from read_book.search_worker import (
    CONNECT_FAILED, DB_ERROR, GET_SPINE_FAILED, UNHANDLED_ERROR, worker_main
)
from read_book.shortcuts import shortcut_for_key_event
from worker import start_worker

CLASS_NAME = 'book-search-container'

add_extra_css(def():
    sel = '.' + CLASS_NAME
    style = build_rule(sel, text_align='right', user_select='none')
    sel += ' > div '
    style += build_rule(sel, display='inline-flex', align_items='center', pointer_events='auto', background_color=get_color('window-background'), padding='1ex')
    return style
)


class SearchOverlay:

    def __init__(self, view):
        self.view = view
        self.search_in_flight_id = None
        c = self.container
        c.classList.add(CLASS_NAME)
        next_button = E.div(class_='simple-link', svgicon('chevron-down'), title=_('Next match'))
        prev_button = E.div(class_='simple-link', svgicon('chevron-up'), title=_('Previous match'))
        prev_button.addEventListener('click', def(ev): self.find_previous();)
        # We cannot use simple link for the close button as it causes the
        # button to remain red when the search panel is re-opened
        close_button = E.div(style='cursor:pointer', svgicon('close'), title=_('Close Search bar'))
        close_button.addEventListener('click', def(ev): window.setTimeout(self.hide, 0);)
        c.appendChild(E.div(
            svgicon('search'), '\xa0',
            create_search_bar(self.find_next, 'search-in-book', placeholder=_('Search') + 'â€¦', button=next_button, associated_widgets=[prev_button, close_button]),
            '\xa0', next_button, '\xa0', prev_button, '\xa0', close_button
        ))
        c.firstChild.addEventListener('keydown', self.onkeydown, {'passive': False})
        self._worker = None
        self.request_counter = 0

    @property
    def worker(self):
        if not self._worker:
            self._worker = start_worker('read_book.search')
            self._worker.onmessage = self.on_worker_message
        return self._worker

    def queue_search(self, query, book, current_name):
        spine = book.manifest.spine
        self.request_counter += 1
        self.search_in_flight_id = self.request_counter
        self.worker.postMessage({
            'type': 'search', 'book_hash': book.book_hash, 'spine': spine, 'current_name': current_name,
            'id': self.request_counter, 'stored_files': book.stored_files, 'query': query
        })

    def on_worker_message(self, evt):
        msg = evt.data
        if msg.type is 'error':
            details = msg.msg
            emsg = _('Unknown error')
            if msg.code is GET_SPINE_FAILED:
                emsg = _('Loading text from the book failed.')
            elif msg.code is CONNECT_FAILED:
                emsg = _('Connecting to database storing the local copy of the book failed in the worker thread.')
            elif msg.code is UNHANDLED_ERROR:
                emsg = _('There was an unhandled error while searching.')
            elif msg.code is DB_ERROR:
                emsg = msg.error.msg
                details = msg.error.details
            error_dialog(_('Could not search'), emsg, details)
        elif msg.id is self.search_in_flight_id:
            if msg.type is 'search_complete':
                self.search_in_flight_id = None
            elif msg.type is 'search_result':
                pass

    def clear_caches(self):
        if self._worker:
            self.worker.postMessage({'type': 'clear_caches'})

    def onkeydown(self, event):
        if event.key is 'Escape' or event.key is 'Esc':
            self.hide()
            event.preventDefault(), event.stopPropagation()
            return
        sc_name = shortcut_for_key_event(event, self.view.keyboard_shortcut_map)
        if sc_name is 'next_match':
            self.find_next()
            event.preventDefault(), event.stopPropagation()
            return
        if sc_name is 'previous_match':
            self.find_previous()
            event.preventDefault(), event.stopPropagation()
            return

    @property
    def container(self):
        return document.getElementById('book-search-overlay')

    @property
    def search_text(self):
        return self.container.querySelector('input').value

    @property
    def is_visible(self):
        return self.container.style.display is not 'none'

    def set_text(self, text):
        self.container.querySelector('input').value = text or ''

    def hide(self):
        self.container.style.display = 'none'
        ui_operations.focus_iframe()

    def show(self):
        c = self.container
        c.style.display = 'block'
        inp = c.querySelector('input')
        inp.focus(), inp.select()

    def find(self, text, backwards):
        if not text:
            return
        self.view.find(text, backwards)

    def find_next(self):
        self.find(self.search_text, False)

    def find_previous(self):
        self.find(self.search_text, True)


def find_in_serialized_html(data, text):
    haystack = text_from_serialized_html(data)
    return haystack.toLowerCase().indexOf(text) > -1


def find_in_spine(names, book, text, proceed):
    text = text.toLowerCase()

    def got_one(data, name, mimetype):
        if find_in_serialized_html(data, text):
            proceed(name)
        else:
            do_one()

    def do_one():
        name = names.shift()
        if name:
            ui_operations.get_file(book, name, got_one)
        else:
            proceed(None)

    do_one()


main = worker_main
