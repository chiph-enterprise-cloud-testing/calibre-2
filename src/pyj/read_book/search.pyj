# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2017, Kovid Goyal <kovid at kovidgoyal.net>
from __python__ import bound_methods, hash_literals

from elementmaker import E

from book_list.globals import get_session_data
from book_list.theme import get_color
from book_list.top_bar import create_top_bar
from complete import create_search_bar
from gettext import gettext as _
from modals import error_dialog
from read_book.globals import current_book, ui_operations
from read_book.resources import text_from_serialized_html
from read_book.search_worker import (
    CONNECT_FAILED, DB_ERROR, GET_SPINE_FAILED, UNHANDLED_ERROR, worker_main
)
from read_book.shortcuts import shortcut_for_key_event
from widgets import create_button
from worker import start_worker


def get_toc_data(book):
    spine = book.manifest.spine
    spine_toc_map = {name: v'[]' for name in spine}
    parent_map = {}
    toc_id_map = {}

    def process_node(node):
        toc_id_map[node.id] = node
        items = spine_toc_map[node.dest]
        if items:
            items.push(node)
        children = node.children
        if children:
            for child in children:
                parent_map[child.id] = node
                process_node(child)

    toc = book.manifest.toc
    if toc:
        process_node(toc)
    return {
        'spine': spine, 'spine_toc_map': spine_toc_map,
        'spine_idx_map': {name: idx for idx, name in enumerate(spine)},
        'parent_map': parent_map, 'toc_id_map': toc_id_map
    }


class SearchOverlay:

    display_type = 'block'
    CONTAINER_ID = 'book-search-overlay'

    def __init__(self, view):
        self.view = view
        self.search_in_flight = {'id': None, 'mode': 'contains', 'case_sensitive': False}
        self._worker = None
        self.request_counter = 0
        c = self.container
        c.style.backgroundColor = get_color('window-background')
        c.addEventListener('keydown', self.onkeydown)

        create_top_bar(c, title=_('Search in book'), action=self.hide, icon='close')

        next_button = create_button(_('Next'), 'chevron-down', tooltip=_('Next match'))
        prev_button = create_button(_('Prev'), 'chevron-up', tooltip=_('Previous match'), action=self.find_previous)
        c.appendChild(E.div(
            style='display: flex; padding: 1rem; padding-bottom: 0.5rem; overflow: hidden',
            create_search_bar(self.find_next, 'search-in-book', button=next_button, associated_widgets=[prev_button]),
            E.div('\xa0\xa0'), next_button, E.div('\xa0\xa0'), prev_button
        ))
        c.lastChild.firstChild.style.flexGrow = '100'
        sd = get_session_data()
        mode = sd.get('book_search_mode')

        c.appendChild(E.div(
            style='display: flex; padding: 1rem; padding-top: 0.5rem; align-items: center; overflow: hidden',
            E.label(
                _('Search type:') + '\xa0',
                E.select(
                    name='mode',
                    title=_('''Type of search:

                    Contains: Search for the entered text anywhere

                    Whole words: Search for whole words that equal the entered text

                    Regex: Interpret the entered text as a regular expression
                    '''),
                    E.option(_('Contains'), value='contains', selected=mode=='contains'),
                    E.option(_('Whole words'), value='word', selected=mode=='word'),
                    E.option(_('Regex'), value='regex', selected=mode=='regex'),
                    onchange=def(event):
                        get_session_data().set('book_search_mode', event.target.checked)
                ),
            ),
            E.div('\xa0\xa0'),
            E.label(E.input(
                type='checkbox', name='case_sensitive', checked=bool(sd.get('book_search_case_sensitive'))),
                onchange=def(event):
                        get_session_data().set('book_search_case_sensitive', event.target.value)
                , _('Case sensitive'),
            ),
            E.div('\xa0\xa0'),
            create_button(_('Return'), 'chevron-left', tooltip=_('Go back to where you were before searching'), action=self.return_to_original_position)
        ))

    @property
    def current_query(self):
        c = self.container
        return {
            'mode': c.querySelector('select[name=mode]').value,
            'case_sensitive': c.querySelector('input[name=case_sensitive]').checked,
            'text': c.querySelector('input[type=search]').value
        }

    @property
    def worker(self):
        if not self._worker:
            self._worker = start_worker('read_book.search')
            self._worker.onmessage = self.on_worker_message
            self.clear_caches()
        return self._worker

    def queue_search(self, query, book, current_name):
        self.request_counter += 1
        self.search_in_flight.id = self.request_counter
        self.worker.postMessage({
            'type': 'search', 'current_name': current_name, 'id': self.request_counter, 'query': query
        })

    def on_worker_message(self, evt):
        msg = evt.data
        if msg.type is 'error':
            details = msg.msg
            emsg = _('Unknown error')
            if msg.code is GET_SPINE_FAILED:
                emsg = _('Loading text from the book failed.')
            elif msg.code is CONNECT_FAILED:
                emsg = _('Connecting to database storing the local copy of the book failed in the worker thread.')
            elif msg.code is UNHANDLED_ERROR:
                emsg = _('There was an unhandled error while searching.')
            elif msg.code is DB_ERROR:
                emsg = msg.error.msg
                details = msg.error.details
            error_dialog(_('Could not search'), emsg, details)
        elif msg.id is self.search_in_flight.id:
            if msg.type is 'search_complete':
                self.search_in_flight.id = None
            elif msg.type is 'search_result':
                console.log(msg)

    def clear_caches(self, book):
        if self._worker:
            book = book or current_book()
            self.toc_data = get_toc_data(book)
            data = {
                'book_hash': book.book_hash, 'stored_files': book.stored_files, 'spine': book.manifest.spine,
                'toc_data': self.toc_data
            }
            self.worker.postMessage({'type': 'clear_caches', 'book': data})

    def onkeydown(self, event):
        if event.key is 'Escape' or event.key is 'Esc':
            self.hide()
            event.stopPropagation()
            return
        sc_name = shortcut_for_key_event(event, self.view.keyboard_shortcut_map)
        if sc_name is 'next_match':
            self.find_next()
            event.stopPropagation()
            return
        if sc_name is 'previous_match':
            self.find_previous()
            event.stopPropagation()
            return

    @property
    def container(self):
        return document.getElementById(self.CONTAINER_ID)

    @property
    def search_text(self):
        return self.container.querySelector('input').value

    @property
    def is_visible(self):
        return self.container.style.display is not 'none'

    def set_text(self, text):
        self.container.querySelector('input').value = text or ''

    def hide(self):
        self.container.style.display = 'none'
        ui_operations.focus_iframe()

    def show(self):
        c = self.container
        c.style.display = self.display_type
        inp = c.querySelector('input')
        inp.focus(), inp.select()

    def find(self, text, backwards):
        if not text:
            return
        self.view.find(text, backwards)

    def find_next(self):
        self.find(self.search_text, False)

    def find_previous(self):
        self.find(self.search_text, True)


def find_in_serialized_html(data, text):
    haystack = text_from_serialized_html(data)
    return haystack.toLowerCase().indexOf(text) > -1


def find_in_spine(names, book, text, proceed):
    text = text.toLowerCase()

    def got_one(data, name, mimetype):
        if find_in_serialized_html(data, text):
            proceed(name)
        else:
            do_one()

    def do_one():
        name = names.shift()
        if name:
            ui_operations.get_file(book, name, got_one)
        else:
            proceed(None)

    do_one()


main = worker_main
